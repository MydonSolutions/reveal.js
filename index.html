<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<style>
			.slide_2 {
				font-size: 30px !important;
			}
			.slide_3 {
				font-size: 30px !important;
			}
		</style>
	</head>
	<body>

		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<h1>Data acquisition bottleneck</h1>
						<p>SETI at the ATA and VLA</p>
						
						<aside class="notes">
							<li>The data from many antenna is processed together to so that it can effect that of a more sensitive antenna.</li>
							<li>The antenna data is collated on processing nodes in realtime.</li>
							<li>This is my vantage point as per SETI's operations at the VLA and ATA.</li>
						</aside>
					</section>

					<section class="slide_2">
						<table>
							<thead>
								<tr>
									<th>
										Dimension
									</th>
									<th>
										<span class="fragment fade-in" data-fragment-index="5">
											Node Partition
										</span>
									</th>
									<th>
										<span class="fragment fade-in" data-fragment-index="9">
											Packet Partition
										</span>
									</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>
										A<span class="fragment fade-in-then-semi-out" data-fragment-index="1">ntenna</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="6">
											\(|A|\)
										</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="10">
											\(1\)
										</span>
									</td>
								</tr>
								<tr>
									<td>
										F<span class="fragment fade-in-then-semi-out" data-fragment-index="2">requency channel</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="7">
											\(F_n\)
										</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="11">
											\(F_p \leq F_n\)
										</span>
									</td>
								</tr>
								<tr>
									<td>
										T<span class="fragment fade-in-then-semi-out" data-fragment-index="3">ime (spectra)</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="8">
											\(t\)
										</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="12">
											\(t_p\)
										</span>
									</td>
								</tr>
								<tr>
									<td>
										P<span class="fragment fade-in-then-semi-out" data-fragment-index="4">olarisation</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="6">
											\(|P|\)
										</span>
									</td>
									<td>
										<span class="fragment fade-in" data-fragment-index="13">
											\(|P|\)
										</span>
									</td>
								</tr>
							</tbody>
						</table>
						
						<aside class="notes">
							<li>There are 4 dimensions of the samples received from the antenna, speaking generally.</li>
							<li>There are the antenna</li>
							<li>The frequency channels</li>
							<li>The axis of time, which enumerates the spectra.</li>
							<li>And the polarisation of the samples.</li>
							<li>Each processing node receives all antenna and all polarisations, as these are critical to the computations.</li>
							<li>The frequency channels are partitioned into sub-bands per processing node.</li>
							<li>The samples are packetised, with the payload covering:</li>
							<li>1 antenna</li>
							<li>A factor of the node's assigned subband over</li>
							<li>A (small) portion of time</li>
							<li>All of the antenna's polarisations</li>
							<li>The bottleneck in the data acquisition is to reconstitute the node's portion of the sky from the packets of data.</li>
						</aside>
					</section>
					
				</section>

				<section>
					<section>
						<h2>Packetised data stream</h2>
						<p>
							Timestamped
						</p>
						<p>
							Unreliable
						</p>
						<span class="fragment fade-in" style="font-style: italic;">
							Metrics of missing data are an important part of metadata.
						</span>

						<aside class="notes">
							<li>
								The packet stream is typically unrealiable as dropped packets are excusable or at least excused, compensating against the complexity of a reliable connection.
							</li>
						</aside>
					</section>
					
					<section>
						<h2>Packetised data stream</h2>
						<h3>Application Header</h3>
						<pre><code data-trim data-noescape data-line-numbers="1|2|3|4">
							uint64_t pktidx;
							uint16_t feng_id;
							uint16_t pkt_schan;
							uint16_t pkt_nchan;
						</code></pre>
					</section>

					<section class="slide_3">
						<h2>
							Packet Payload Collation (AFTP)
						</h2>
						
						<table>
							<thead>
								<tr>
									<th></th>
									<th>A</th>
									<th>F</th>
									<th>T</th>
									<th>P</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Packet</td>
									<td>\(1\)</td>
									<td>\(F_p\)</td>
									<td>\(T_p\)</td>
									<td>\(|P|\)</td>
								</tr>
								<tr>
									<td>Node</td>
									<td>\(|A|\)</td>
									<td>\(F_n\)</td>
									<td>\(T_b\)</td>
									<td>\(|P|\)</td>
								</tr>
							</tbody>
						</table>

						<p class="fragment fade-in">
							\(F_p\) copies of \(T_p \times |P|\) samples, per packet.
						</p>

						<aside class="notes">
							<li>The first output data format is the most long-standing and the packet payload matches up neatly.</li>
							<li>Typically, the payloads are complex 8-bit samples, 2 polarisations, 16-32 spectra per packet and 32-64 channels per packet:</li>
							<li>so it's 64-128 bytes copies at a time, 64-32 per packet, per packet-subband factor, per antenna, per packet-spectra span.</li>
							<li>Order of 1 - 1.5 million packets per second.</li>
						</aside>
					</section>

					<section class="slide_3">
						<h2>
							Packet Payload Collation (xGPU-DP4A)
						</h2>
						<!-- 
							// to xGPU(DP4A)-Correlator input:
//    [Slowest -> Fastest]
//    Time        [0 ... PIPERBLK/4]
//    Channel     [0 ... NCHAN]
//    FENG        [0 ... NANT]
//    POL         [0 ... NPOL]
//    complexity  [real, imag]
//    time_minor  [0 ... 4]
						 -->
						 
						<table>
							<thead>
								<tr>
									<th></th>
									<th>A</th>
									<th>F</th>
									<th>\(T_m\)</th>
									<th>\(T_4\)</th>
									<th>P</th>
									<th>Complexity</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Packet</td>
									<td>\(1\)</td>
									<td>\(F_p\)</td>
									<td>\(T_p\div4\)</td>
									<td>\(4\)</td>
									<td>\(|P|\)</td>
									<td>\(2\)</td>
								</tr>
							</tbody>
						</table>
						
						<table class="fragment fade-in">
							<thead>
								<tr>
									<th></th>
									<th>\(T_m\)</th>
									<th>F</th>
									<th>A</th>
									<th>P</th>
									<th>Complexity</th>
									<th>\(T_4\)</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Node</td>
									<th>\(T_b\div4\)</th>
									<th>\(F_n\)</th>
									<th>\(|A|\)</th>
									<th>\(|P|\)</th>
									<th>\(2\)</th>
									<th>\(4\)</th>
								</tr>
							</tbody>
						</table>

						<p class="fragment fade-in">
							\(F_p \times T_p \div 4 \) copies of \(4 \times |P|\) samples, per packet.
						</p>
						
						<aside class="notes">
							<li>The second output data format is according to the DP4A input of xGPU, a veteran correlation library.</li>
							<li>The time dimension of the packet payload is expanded into major and minor sub-axes, the minor being 4 spectra long.</li>
							<li>And the complex samples are broken up into their components along the "Complexity" dimension.</li>
							<li>...</li>
							<li>Whilst this incurs more copies of smaller portions, the observed throughput for this mode is much higher. This indicates that the SSE3 intrinsic is more efficiently moving the data.</li>
						</aside>
					</section>

					<section>
						<p>Contemporary ConnectX 100 Gb NICs</p>
						<p>AMD EPYC 16/24 core CPUS</p>
						<p>Achieving ~8 GB/s</p>
						<p class="fragment fade-in">Using 1 IBVerbs Flow Specification</p>
						<p class="fragment fade-in">Using 12 CPU cores</p>
						
						<aside class="notes">
							<li>The nodes have contemporary hardware that allows throughputs of up to 8 GB/s, without packet drops.</li>
							<li>The current software implementation only employs 1 IBVerb Flow specification to essentially offload only the intterupts of the packets.</li>
							<li>The CPU still is employed to read through application headers and reorder the data, noting any data missing from the block at hand.</li>
						</aside>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				progress: true,
				center: true,
				controls: true,
				transition: "none",

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>
